#!/usr/bin/env ruby
#
# == Synopsis 
#   This programm generates a group mobility model
#   specified through the as argument specification
#
# == Examples
#   This command print out some simple statistics
#     grmoge scenario.conf
#
# == Usage 
#   grmoge [options] <scenario-files>
#
#   For help use: grmoge -h
#
# == Options
#   -h, --help          Displays help message
#   -v, --verbose       Verbose output
#   -V, --version       Display the version, then exit
#   -q, --quiet         Output as little as possible, overrides verbose
#   -f, --format        Specify the output format (ns2)
#   -p, --plot          Plot terrain map
#
# == Author
#   Hagen Paul Pfeifer <hagen@jauu.net>
#
# == Copyright
#   Copyright (c) 2008 Hagen Paul Pfeifer



# max count of coordinate cells
$max_area_division = 100



class TerrainMap

	attr_accessor :x, :y, :options

	def initialize( x, y, options )

		@x = x
		@y = y
		@options = options

		area_size = determine_coordinate_area_size( x, y)
		$stderr.puts "coordinates x: #{area_size[0]} y: #{area_size[1]}" if @options.verbose
		map = generate_terrain_map( area_size )
		plot_terrain_map( map ) if @options.plotterrain

	end

	# both ranges are inclusive
	def random( min, max )
		rand(max - min + 1) + min
	end


	def generate_terrain_map( area_size )

		ret = Array.new

		# generate random height points
		area_size[0].times do |x|
			ret[x] = Array.new
			area_size[1].times do |y|
				ret[x][y] = random(0, 10)
			end
		end


		for n in (0..1)
			for x in (0..area_size[0] - 1)
				for y in (0..area_size[1] - 1)
					for a in [-1, 0, 1]
						for b in [-1, 0, 1]
							if (x + a >= 0 && x + a < area_size[0] &&
									y + b >= 0 && y + b < area_size[1])
								ret[x][y] += ret[x+a][y+b]
							end
						end
					end
					ret[x][y] *= 0.075
				end
			end
		end

		return ret

	end

	def determine_coordinate_area_size( x, y)

		if x > y
			longest_edge  = x
			shortest_edge = y
			x_is_larger   = true
		else
			longest_edge  = y
			shortest_edge = x
			x_is_larger   = false
		end


		puts "x #{shortest_edge.to_f} y #{y}"

		ratio = (shortest_edge.to_f / longest_edge) * $max_area_division


		if x_is_larger == true
			return [ $max_area_division, ratio.ceil ]
		else
			return [ ratio.ceil , $max_area_division ]
		end
	end




	def plot_terrain_map( map )

		require 'tmpdir'

		curdir = Dir.getwd
		tmpdir = Dir.mktmpdir

		Dir.chdir(tmpdir)

		# write data file
		fh = open("terrain.data", "w");
		i = j = 1
		map.each do |x|
			x.each do |y|
				fh.puts "#{i} #{j} #{y} "
				j += 1
			end
			fh.puts "\n"
			i += 1
			j = 1
		end
		fh.close

		# write gnuplot file
		gfh = open("terrain.gpi", "w");
		gfh.puts "set term postscript eps enhanced monochrome"
		gfh.puts "set terminal postscript enhanced \"Times\" 40"
		gfh.puts "set output \"terrain.eps\""
		gfh.puts "set size 4"
		gfh.puts "set pm3d"
		gfh.puts "splot \"terrain.data\" title \"Terrain Penalty Map\" with lines"
		gfh.close

		# generate eps and convert to pdf instantly
		system("gnuplot terrain.gpi")
		system("epstopdf --outfile=terrain.pdf terrain.eps")
		system("cp terrain.pdf #{curdir}")


		# jump back to our origin
		Dir.chdir(curdir)

		# delete tmp dir
		Dir.foreach(tmpdir) do |file|
			next if File.directory?(file)
			File.delete(tmpdir + "/" + file)
		end
		Dir.delete(tmpdir)

	end

end # class Terrain Map


class GrMoGe

	require 'optparse' 
	require 'rdoc/usage'
	require 'ostruct'
	require 'date'

	attr_accessor :options, :scenario_file

	$scenario = nil

	def deg2rad( d )
		( d / 180.0 ) * Math::PI
	end

	def rad2deg( r )
		( r / Math::PI ) * 180
	end


	def validate_scenario

		if !$scenario.include?( "Map" )
			puts "Your scenario did not specify a map (size)"
			exit( 1 )
		end

		if $scenario["Map"]["Size"][0] <= 0 or
			$scenario["Map"]["Size"][1] <= 0
			puts "Your specified map size is to small!"
			exit( 1 )
		end

		true
	end

	# both ranges are inclusive
	def random( min, max )
		rand(max - min + 1) + min
	end

	def eval_scenario_file( filename )
		file = File.new( filename, 'r' )
		buffer = "$scenario = {\n"
		buffer += file.read
		buffer += "\n}"
		file.close
		eval( buffer )
		if $scenario == nil
			puts "Your configuraion file did not specify a valid scenario, exiting"
			exit 1
		end
	end



	def initialize( arguments, stdin )
		@arguments = arguments
		@stdin = stdin

		# Set defaults
		@options = OpenStruct.new
		@options.verbose = false
		@options.quiet = false
		@options.plotterrain = false

	end

	# Parse options, check arguments, then process the command
	def parse_arguments

		if parsed_options? && arguments_valid? 

			process_arguments            

		else
			output_usage
		end

	end

	def parsed_options?

		# Specify options
		opts = OptionParser.new 
		opts.on('-V',        '--version')    { output_version ; exit 0 }
		opts.on('-h',        '--help')       { output_help }
		opts.on('-v',        '--verbose')    { @options.verbose = true }  
		opts.on('-q',        '--quiet')      { @options.quiet = true }
		opts.on('-p',        '--plot')       { @options.plotterrain = true }
		opts.on('-f [format]', '--format')   { |format| @options.format = format}

		opts.parse!(@arguments) rescue return false

		process_options
		true      
	end

	def process_options
		@options.verbose = false if @options.quiet
	end

	def arguments_valid?
		true if @arguments.length == 1 
	end

	# Setup the arguments
	def process_arguments
		@scenario_file = @arguments[0]
	end

	def output_help
		output_version
		RDoc::usage()
	end

	def output_usage
		RDoc::usage('usage')
	end

	def output_version
		$stderr.puts "#{File.basename(__FILE__)} version"
	end

	def run

		$stderr.puts "grmoge - Copyright (c) 2008 Hagen Paul Pfeifer" if @options.verbose
		$stderr.puts "parse scenario file: #{@scenario_file}" if @options.verbose

		# init
		eval_scenario_file( @scenario_file )
		validate_scenario

		#generate map
		map = TerrainMap.new( $scenario["Map"]["Size"][0],
									        $scenario["Map"]["Size"][1], @options )

		groups = parse_groups( $scenario )

	end

	private

	def parse_groups( scenario )

		$stderr.puts "# parse groups" if @options.verbose

	end


end


grmoge = GrMoGe.new(ARGV, STDIN)
grmoge.parse_arguments
grmoge.run
