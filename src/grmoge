#!/usr/bin/env ruby
#
# == Synopsis 
#   This programm generates a group mobility model
#   specified through the as argument specification
#   bla blub
#
# == Examples
#   This command print out some simple statistics
#   grmoge scenario.conf
#
# == Usage 
#   grmoge [options] <scenario-files>
#
#   For help use: grmoge -h
#
# == Options
#   -h, --help          Displays help message
#   -v, --verbose       Verbose output
#   -V, --version       Display the version, then exit
#   -q, --quiet         Output as little as possible, overrides verbose
#   -f, --format        Specify the output format (ns2)
#   -p, --plotterrain   Plot terrain map
#
# == Author
#   Hagen Paul Pfeifer <hagen@jauu.net>
#
# == Copyright
#   Copyright (c) 2008 Hagen Paul Pfeifer



# max count of coordinate cells
$max_area_division = 100


# only for developing process relevant
$run_unit_tests = false


class Group

	attr_accessor :name, :waypoints

	public


	def initialize( group, terrain_map )

		@name      = group["Name"] ? group["Name"] : "nameless"
		@waypoints = group["Waypoints"]

		if group["VelocityMode"]
			if (group["VelocityMode"].casecmp( "uniform" ))
				@velocity_mode = :uniform
			elsif (group["VelocityMode"].casecmp( "variable" ))
				@velocity_mode = :variable
			else
				GrMoGe.err "not a valid velocity mode: #{group["VelocityMode"]}"
			end

		else
			@velocity_mode = :uniform
		end

		sanity_check( terrain_map )

	end

	private

	def sanity_check( terrain_map )

		if @waypoints.size < 2
			GrMoGe.err "At least two waypoints must be specified"
		end

		# check if the given waypoints are within the
		# terrain map
		@waypoints.each do |wa|
			x = wa[1][0]
			y = wa[1][1]
			if terrain_map.points_within_map( x, y) == false
				GrMoGe.err "Waypoint x #{x} y #{y} not valid (outside the map)"
			end

		end

	end


end # Group



class TerrainMap

	attr_accessor :terrain_map
	attr_accessor :field_edge_length
	attr_accessor :fields_x, :fields_y
	attr_accessor :x, :y, :options

	public



	def initialize( x, y, options )

		@x = x
		@y = y
		@options = options

		determine_coordinate_area_size( x, y )
		generate_terrain_map

	end



	# determine field for the given
	# coordinate (x,y) and return the
	# corresponding penalty
	def score_for_coordinate( x, y )
		
		search_x = (x / @field_edge_length).to_i
		search_y = (y / @field_edge_length).to_i

		return @terrain_map[search_x][search_y]
	end

	def points_within_map( x, y)
		if x < 0 or y < 0 or x > @x or y > @y
			return false
		else
			return true
		end
	end


	def plot_terrain_map

		require 'tmpdir'

		curdir = Dir.getwd
		tmpdir = Dir.mktmpdir

		Dir.chdir(tmpdir)

		# write data file
		fh = open("terrain.data", "w");
		i = j = 1
		@terrain_map.each do |x|
			x.each do |y|
				fh.puts "#{i} #{j} #{y} "
				j += 1
			end
			fh.puts "\n"
			i += 1
			j = 1
		end
		fh.close

		# write gnuplot file
		gfh = open("terrain.gpi", "w");
		gfh.puts "set term postscript eps enhanced monochrome"
		gfh.puts "set terminal postscript enhanced \"Times\" 40"
		gfh.puts "set output \"terrain.eps\""
		gfh.puts "set size 4"
		gfh.puts "set pm3d"
		gfh.puts "splot \"terrain.data\" title \"Terrain Penalty Map\" with lines"
		gfh.close

		# generate eps and convert to pdf instantly
		system("gnuplot terrain.gpi")
		system("epstopdf --outfile=terrain.pdf terrain.eps")
		system("cp terrain.pdf #{curdir}")


		# jump back to our origin
		Dir.chdir(curdir)

		# delete tmp dir
		Dir.foreach(tmpdir) do |file|
			next if File.directory?(file)
			File.delete(tmpdir + "/" + file)
		end
		Dir.delete(tmpdir)

	end



	def unit_test
		100000.times do
			x_test = random( 0, @x )
			y_test = random( 0, @y )
			puts "terrain score test for x #{x_test} y #{y_test}"
			score_for_coordinate( x_test, y_test )
		end
	end



	private



	# both ranges are inclusive
	def random( min, max )
		rand(max - min + 1) + min
	end



	def generate_terrain_map

		@terrain_map = Array.new

		# generate random height points
		@fields_x.times do |x|
			@terrain_map[x] = Array.new
			@fields_y.times do |y|
				@terrain_map[x][y] = random(0, 10)
			end
		end


		for n in (0..1)
			for x in (0..@fields_x - 1)
				for y in (0..@fields_y - 1)
					for a in [-1, 0, 1]
						for b in [-1, 0, 1]
							if (x + a >= 0 && x + a < @fields_x &&
									y + b >= 0 && y + b < @fields_y)
								@terrain_map[x][y] += @terrain_map[x+a][y+b]
							end
						end
					end
					@terrain_map[x][y] *= 0.075
				end
			end
		end

	end



	def determine_coordinate_area_size( x, y)

		if x > y
			longest_edge  = x
			shortest_edge = y
			x_is_larger   = true
		else
			longest_edge  = y
			shortest_edge = x
			x_is_larger   = false
		end

		ratio = (shortest_edge.to_f / longest_edge) * $max_area_division

		@field_edge_length = longest_edge / $max_area_division

		if x_is_larger == true
			@fields_x = $max_area_division + 1
			@fields_y = ratio.ceil
		else
			@fields_x = ratio.ceil
			@fields_y = $max_area_division + 1
		end
	end



end # class Terrain Map



class GrMoGe

	require 'optparse' 
	require 'rdoc/usage'
	require 'ostruct'
	require 'date'


	attr_accessor :options, :scenario_file
	$scenario = nil


	public

	def deg2rad( d )
		( d / 180.0 ) * Math::PI
	end



	def rad2deg( r )
		( r / Math::PI ) * 180
	end



	def validate_scenario

		if !$scenario.include?( "Map" )
			puts "Your scenario did not specify a map (size)"
			exit( 1 )
		end

		if $scenario["Map"]["Size"][0] <= 0 or
			 $scenario["Map"]["Size"][1] <= 0
			puts "Your specified map size is to small!"
			exit( 1 )
		end

		true
	end



	# both ranges are inclusive
	def random( min, max )
		rand(max - min + 1) + min
	end

	def eval_scenario_file( filename )

		$stderr.puts "# parse scenario file: #{@scenario_file}" if @options.verbose

		file = File.new( filename, 'r' )

		buffer = "$scenario = {\n"
		buffer += file.read
		buffer += "\n}"

		file.close

		eval( buffer )

		if $scenario == nil
			puts "Your configuraion file did not specify a valid scenario, exiting"
			exit 1
		end

	end



	def initialize( arguments, stdin )
		@arguments = arguments
		@stdin = stdin

		# Set defaults
		@options = OpenStruct.new
		@options.verbose = false
		@options.quiet = false
		@options.plotterrain = false

	end



	# Parse options, check arguments, then process the command
	def parse_arguments

		if parsed_options? && arguments_valid? 

			process_arguments            

		else
			output_usage
		end

	end



	def parsed_options?

		# Specify options
		opts = OptionParser.new 
		opts.on('-V',        '--version')     { output_version ; exit 0 }
		opts.on('-h',        '--help')        { output_help }
		opts.on('-v',        '--verbose')     { @options.verbose = true }  
		opts.on('-q',        '--quiet')       { @options.quiet = true }
		opts.on('-p',        '--plotterrain') { @options.plotterrain = true }
		opts.on('-f [format]', '--format')    { |format| @options.format = format}

		opts.parse!(@arguments) rescue return false

		process_options
		true      
	end



	def process_options
		@options.verbose = false if @options.quiet
	end



	def arguments_valid?
		true if @arguments.length == 1 
	end



	# Setup the arguments
	def process_arguments
		@scenario_file = @arguments[0]
	end



	def output_help
		output_version
		RDoc::usage()
	end



	def output_usage
		RDoc::usage('usage')
	end



	def output_version
		$stderr.puts "#{File.basename(__FILE__)} version"
	end



	def run

		$stderr.puts "grmoge - Copyright (c) 2008 Hagen Paul Pfeifer"

		# init
		eval_scenario_file( @scenario_file )
		validate_scenario

		#generate map
		map = TerrainMap.new( $scenario["Map"]["Size"][0],
									        $scenario["Map"]["Size"][1], @options )
		if $run_unit_tests
			map.unit_test
		end

		# plot map if user request it
		map.plot_terrain_map if @options.plotterrain


		groups = parse_groups( $scenario, map )

	end

	def GrMoGe.err( text )
		$stderr.puts("ERROR: #{text}")
		exit( 1 )
	end



	private


	def parse_groups( scenario, map )

		groups = Array.new

		$stderr.puts "# parse groups" if @options.verbose
		scenario["Groups"].each do |group|
			groups << Group.new(group, map)
		end

		$stderr.puts "# found #{groups.size} groups" if @options.verbose

	end



end




grmoge = GrMoGe.new(ARGV, STDIN)
grmoge.parse_arguments
grmoge.run
